---
title: "Part 3: Modelling with R"
author: Ver√≥nica Andreo
date: '`r Sys.Date()`'
format: 
  html: 
    code-tools: true
    code-copy: true
    code-fold: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(eval = FALSE)
# knitr::opts_chunk$set(cache = TRUE)
```

In this third part of the studio, we'll use R to model *Aedes albopictus*
distribution in Northern Italy. For that, we need to connect to GRASS via
the `rgrass` package in order to read occurrence data and predictors. The 
*rgrass* package is developed by @rgrass and can be found at: 
<https://github.com/rsbivand/rgrass/>. See the vignette with explanations
and examples at: <https://rsbivand.github.io/rgrass/>.

## [**rgrass**](https://cran.r-project.org/web/packages/rgrass/index.html)

- `initGRASS()`: starts a GRASS GIS session from R
- `execGRASS()`: executes GRASS GIS commands 
- `gmeta()`: shows GRASS location metadata
- `read_VECT()` and `read_RAST()`: read vector and raster maps from GRASS into R *terra* objects.
- `write_VECT()` and `write_RAST()`: write R *terra* objects into the GRASS GIS database

::: {.callout-note}
Package `terra` is developed by @terra and will eventually replace `raster`.
:::

## Usage

GRASS GIS and R can be used together in two ways:

A. Using [R within a GRASS GIS session](https://grasswiki.osgeo.org/wiki/R_statistics/rgrass7#R_within_GRASS), i.e. starting R (or RStudio) from GRASS terminal
<br>

- type `R` or `rstudio &` in the GRASS GIS terminal
- load `rgrass` library
- use `read_VECT()`, `read_RAST()` to read data from GRASS into R
- access GRASS GIS modules and database through `execGRASS()`
- write data (back) to GRASS database with `write_VECT()` and `write_RAST()`


![](assets/img/studio/grass_terminal_calling_R.png){width="60%" fig-align="center"}

B. Using [GRASS GIS within an R session](https://grasswiki.osgeo.org/wiki/R_statistics/rgrass7#GRASS_within_R), i.e. we connect to GRASS GIS database from within R (or RStudio).
<br>

- we need to start GRASS GIS with `initGRASS()` from R
- we access GRASS GIS modules through `execGRASS()`
- use `read_VECT()`, `read_RAST()`, `write_VECT()` and `write_RAST()` to read data from and to GRASS database

::: {.callout-note}
`rgrass` was originally intended to apply GRASS functions on data outside GRASS database; hence some prefer to create throw away locations
:::

![](assets/img/studio/grass_within_rstudio_session.png){width="70%" fig-align="center"}

# Let's move to R

### Load packages needed

```{r load_libraries, message=FALSE}
library(rgrass)
library(sf)
library(terra)
library(raster)
library(mapview)
library(biomod2)
library(dismo)
library(usdm)
library(SDMtune)
library(zeallot)
```

### Initialize GRASS

We'll use **option B**, i.e., we'll launch GRASS, in a defined location and mapset, from R

```{r}
#| label: grass_init
#| message: false

# path to GRASS binaries (run `grass --config path`)
grassbin <- "/usr/lib64/grass82"
# path to GRASS database
grassdata <- "/home/veroandreo/grass_ncsu_2023/grassdata/"
# path to location
location <- "eu_laea"
# path to mapset
mapset <- "italy_LST_daily"

# start GRASS GIS from R
initGRASS(gisBase = grassbin, 
          home = tempdir(), 
          gisDbase = grassdata, 
          location = location, 
          mapset = mapset, 
          override = TRUE,
          remove_GISRC= TRUE)
```

### Read vector data

Now we read in the occurrence data and the background points hosted in GRASS, convert them to `sf` objects and display them with `mapview`.

```{r}
#| label: read_vectors
#| message: false
#| warning: false
#| results: hide

# Read vector layers
presence <- st_as_sf(read_VECT("aedes_albopictus"))
background <- st_as_sf(read_VECT("background_points"))
```

```{r ref.label='plot'}
#| warning: false

# Display vectors
mapview(presence) + 
  mapview(background, color="black", col.regions="black", cex=2)
```


#### Read raster data

```{r}
#| label: read_rasters
#| message: false
#| warning: false
#| results: hide

# List rasters by pattern
worldclim <- execGRASS("g.list", 
                       parameters = list(type = "raster", 
                                         pattern = "worldclim*"))
avg <- execGRASS("g.list", 
                 parameters = list(type = "raster", 
                                   pattern = "avg*"))
median <- execGRASS("g.list", 
                    parameters = list(type = "raster", 
                                      pattern = "median*", 
                                      exclude = "*[1-5]"))

# Concatenate map lists
to_import <- c(attributes(worldclim)$resOut, 
               attributes(avg)$resOut, 
               attributes(median)$resOut)

# Read raster layers
predictors <- list()
for (i in to_import){ 
  predictors[i] <- raster(read_RAST(i)) }

# Stack rasters
predictors_r <- raster::stack(predictors)
```


```{r}
#| label: quick_view
#| message: false
#| warning: false

# Quick visualization in mapview
mapview(predictors_r[['worldclim_bio01']]) + presence
```

#### Data preparation

```{r}
#| label: data_prep1
#| message: false
#| warning: false

# Variables for models
sp <- "Aedes albopictus"
presence_coords <- st_coordinates(presence)
background <- st_coordinates(background)
env <- predictors_r

# Prepare data: SWD
data_sp <- prepareSWD(species = sp, 
                      p = presence_coords, 
                      a = background, 
                      env = env)

data_sp
```

### Define relevant variables

```{r}
seed=49
perc_test = 0.2
k = 4
method="Maxent"
cor_th=0.7
perm=10
```

### Create train and test datasets

```{r}
# Create training and test sets
c(train_sp, test_sp) %<-% 
  trainValTest(data_sp, 
               test = perc_test,
               only_presence = TRUE, 
               seed = seed)

```

```{r}
train_sp
```

```{r}
test_sp
```

### Create folds for cross-validation

```{r}
# Create folds 
ran_folds <- randomFolds(train_sp, 
                         k = k,
                         only_presence = TRUE, 
                         seed = seed)
```

### Train a default Maxent model with CV

```{r}
#| message: false
#| warning: false

# Train a full model
full_model_sp <- train(method = method,
                       data = train_sp, 
                       folds = ran_folds)

full_model_sp
```

```{r}
pred_full_model <- predict(full_model_sp,
                           data = env,
                           type = "cloglog")

mapview(pred_full_model)
```

### Variable selection: remove highly correlated variables 

```{r}
#| warning: false

# Prepare background locations to test correlation
bg_sp <- prepareSWD(species = sp, 
                    a = background,
                    env = env)

# Remove variables with correlation higher than 0.7 
# while accounting for the AUC
vs_sp <- varSel(full_model_sp,
                metric = "auc", 
                bg4cor = bg_sp, 
                cor_th = cor_th,
                permut = perm)

```

```{r}
vs_sp@data
```

### Remove less important variables

```{r}
# remove less important variables only if auc does not decrease
reduc_var_sp <- reduceVar(vs_sp,
                          th = 10, 
                          metric = "auc", 
                          test = TRUE, 
                          permut = perm, 
                          use_jk = TRUE)

reduc_var_sp
```

We need now to recreate SWD only with the selected variables to run the final 
model and make predictions.

```{r}
# Get only relevant variables from the reduced model
retained_varnames <- names(reduc_var_sp@models[[1]]@data@data)

# Subset raster stack
env <- subset(env, retained_varnames)

# SWD with the selected vars
subset_train_sp <- prepareSWD(species = sp, 
                              p = presence,
                              a = background,
                              env = env)

c(train_sp, test_sp) %<-% 
  trainValTest(subset_train_sp, 
               test = perc_test, 
               only_presence = TRUE, 
               seed = seed)
```

### Run the best model with the full train data

```{r}
final_model_sp <- train(method = method, 
                        data = train_sp,
                        fc = reduc_var_sp@models[[1]]@model@fc,
                        reg = reduc_var_sp@models[[1]]@model@reg)
```

### Make predictions with the final model

```{r}
map_sp_maxent <- predict(final_model_sp,
                         data = env, 
                         type = "cloglog")

mapview(map_sp_maxent)
```

### Write raster of final model predictions to GRASS 

```{r}
write_RAST(rast(map_sp_maxent), 
           "Aedes_albopictus_maxent", 
           flags = c("o","overwrite"))
```

```{r}
execGRASS("g.list", parameters = list(type="raster",
                                      pattern="Aedes*"))
```

### Model evaluation

```{r}
# AUC
auc_maxent <- auc(final_model_sp, test = test_sp)
auc_maxent
```

```{r}
# Threshold dependent evaluation
th_maxent <- thresholds(final_model_sp, 
                        type = "cloglog", 
                        test = test_sp)

knitr::kable(th_maxent, format = 'html', digits = 2)
```

### Variable importance in final model

```{r}
vi_model_sp <- maxentVarImp(final_model_sp)
vi_model_sp
```

```{r}
plotVarImp(vi_model_sp)
```


### Response curves in final model

```{r}
my_rp <- function(i){
  plotResponse(reduc_var_sp, i)
}

plotlist <- lapply(retained_varnames, my_rp)

labels <- LETTERS[1:length(retained_varnames)]

ggpubr::ggarrange(plotlist = plotlist, labels = labels)
```


```{r}
# close the mapset
unlink_.gislock()
```


### Disclaimer

This is only a toy example and only the beginning...

- other models to test
- hyper-parameter tuning
- ensemble modeling
- model validation with independent data
- uncertainty: where we can predict with confidence
- many other relevant packages: 
  - [*dismo*](https://cran.r-project.org/web/packages/dismo/index.html), [*sdm*](https://cran.r-project.org/web/packages/sdm/index.html),  [*kuenm*](https://github.com/marlonecobos/kuenm), [*caret*](https://cran.r-project.org/web/packages/caret/index.html), [*CAST*](https://cran.r-project.org/web/packages/CAST/index.html), etc.

## References

:::{#refs}

:::