{
  "hash": "beafe7b1816c3edb7aec6bcc6873bf01",
  "result": {
    "markdown": "---\ntitle: \"Part 3: Modelling with R\"\nauthor: Ver√≥nica Andreo\ndate: '2023-04-06'\nformat: \n  html: \n    code-tools: true\n    code-copy: true\n    code-fold: false\n---\n\n\n\n\nIn this third part of the studio, we'll use R to model *Aedes albopictus*\ndistribution in Northern Italy. For that, we need to connect to GRASS via\nthe `rgrass` package in order to read occurrence data and predictors. The \n*rgrass* package is developed by @rgrass and can be found at: \n<https://github.com/rsbivand/rgrass/>. See the vignette with further\nexplanations and examples at: <https://rsbivand.github.io/rgrass/>.\n\n# [**rgrass**](https://cran.r-project.org/web/packages/rgrass/index.html)\n\n- `initGRASS()`: starts a GRASS GIS session from R\n- `execGRASS()`: executes GRASS GIS commands \n- `gmeta()`: shows GRASS location metadata\n- `read_VECT()` and `read_RAST()`: read vector and raster maps from GRASS into R *terra* objects.\n- `write_VECT()` and `write_RAST()`: write R *terra* objects into the GRASS GIS database\n\n::: {.callout-note}\nPackage `terra` is developed by @terra and will eventually replace `raster`.\n:::\n\n## Usage\n\nGRASS GIS and R can be used together in two ways:\n\nA. Using [R within a GRASS GIS session](https://grasswiki.osgeo.org/wiki/R_statistics/rgrass7#R_within_GRASS), i.e. starting R (or RStudio) from GRASS terminal\n<br>\n\n- type `R` or `rstudio &` in the GRASS GIS terminal\n- load `rgrass` library\n- use `read_VECT()`, `read_RAST()` to read data from GRASS into R\n- access GRASS GIS modules and database through `execGRASS()`\n- write data (back) to GRASS database with `write_VECT()` and `write_RAST()`\n\n\n![](assets/img/studio/grass_terminal_calling_R.png){width=\"60%\" fig-align=\"center\"}\n\nB. Using [GRASS GIS within an R session](https://grasswiki.osgeo.org/wiki/R_statistics/rgrass7#GRASS_within_R), i.e. we connect to GRASS GIS database from within R (or RStudio).\n<br>\n\n- we need to start GRASS GIS with `initGRASS()` from R\n- we access GRASS GIS modules through `execGRASS()`\n- use `read_VECT()`, `read_RAST()`, `write_VECT()` and `write_RAST()` to read data from and to GRASS database\n\n::: {.callout-note}\n`rgrass` was originally intended to apply GRASS functions on data outside GRASS database; hence some prefer to create throw away locations\n:::\n\n![](assets/img/studio/grass_within_rstudio_session.png){width=\"70%\" fig-align=\"center\"}\n\n# SDM workflow\n\nIn this part of the Studio we'll be covering the middle and right side of the\nSDM workflow, modeling and predictions.\n\n![](assets/img/lecture/workflow_sdm_other.png)\n\nThere are several packages to carry out SDM, in this case we'll be using\n[SDMtune](https://cloud.r-project.org/web/packages/SDMtune/index.html) by @sdmtune. It provides functions covering the whole SDM workflow, from data \npreparation, to variable selection, optimization and evaluation. Have a look\nat the articles on the package website for further details: <https://consbiol-unibern.github.io/SDMtune/index.html>.\n\n\n# Let's move to R\n\n### Load packages needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rgrass)\nlibrary(sf)\nlibrary(terra)\nlibrary(mapview)\nlibrary(biomod2)\nlibrary(dismo)\nlibrary(usdm)\nlibrary(SDMtune)\nlibrary(zeallot)\n```\n:::\n\n\n### Initialize GRASS\n\nWe'll use **option B**, i.e., we'll launch GRASS GIS in a defined location and mapset, from R\n\n\n::: {.cell .panel-tabset}\n\n```{.r .cell-code}\n# path to GRASS binaries (run `grass --config path`)\ngrassbin <- \"/usr/lib64/grass82\"\n# path to GRASS database\ngrassdata <- \"/home/veroandreo/grass_ncsu_2023/grassdata/\"\n# path to location\nlocation <- \"eu_laea\"\n# path to mapset\nmapset <- \"italy_LST_daily\"\n\n# start GRASS GIS from R\ninitGRASS(gisBase = grassbin, \n          home = tempdir(), \n          gisDbase = grassdata, \n          location = location, \n          mapset = mapset, \n          override = TRUE,\n          remove_GISRC= TRUE)\n```\n:::\n\n\n### Read vector data\n\nNow we read in the occurrence data and the background points hosted in GRASS, convert them to `sf` objects and display them with `mapview`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read vector layers\npresence <- st_as_sf(read_VECT(\"aedes_albopictus\"))\nbackground <- st_as_sf(read_VECT(\"background_points\"))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n#### Read raster data\n\nWe read now all the variables that we derived from the daily LST time series.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List rasters by pattern\nworldclim <- execGRASS(\"g.list\", \n                       parameters = list(type = \"raster\", \n                                         pattern = \"worldclim*\"))\navg <- execGRASS(\"g.list\", \n                 parameters = list(type = \"raster\", \n                                   pattern = \"avg*\"))\nmedian <- execGRASS(\"g.list\", \n                    parameters = list(type = \"raster\", \n                                      pattern = \"median*\", \n                                      exclude = \"*[1-5]\"))\n\n# Concatenate map lists\nto_import <- c(attributes(worldclim)$resOut, \n               attributes(avg)$resOut, \n               attributes(median)$resOut)\n\n# Read raster layers\npredictors <- list()\nfor (i in to_import){ \n  predictors[i] <- read_RAST(i) }\n\n# Stack rasters\npredictors_r <- rast(predictors)\n```\n:::\n\n\nLet's visualize imported maps. Note we convert *terra* object into *raster* \nbecause `mapview` does not support terra yet. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quick visualization in mapview\nmapview(raster::raster(predictors_r[['worldclim_bio01']])) + presence\n```\n:::\n\n\n#### Data preparation\n\nNow that we have imported presence records, background points and predictor\nvariables derived from LST time series, we need to prepare the data in a\nformat called *samples with data* (SWD). This is basically a table with presence\nand background coordinates plus the corresponding values in the predictor\nvariables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Variables for models\nsp <- \"Aedes albopictus\"\npresence_coords <- st_coordinates(presence)\nbackground <- st_coordinates(background)\nenv <- predictors_r\n\n# Prepare data: SWD\ndata_sp <- prepareSWD(species = sp, \n                      p = presence_coords, \n                      a = background, \n                      env = env)\n\ndata_sp\n```\n:::\n\n\n### Define relevant variables\n\nWe define here some of the input values required through the workflow:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseed=49\nperc_test = 0.2\nk = 4\nmethod=\"Maxent\"\ncor_th=0.7\nperm=10\nimp_th=10\n```\n:::\n\n\n### Create train and test datasets\n\nWe will train the model with an 80% of presence samples, and leave the remaining\n20% for evaluation at the end.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create training and test sets\nc(train_sp, test_sp) %<-% \n  trainValTest(data_sp, \n               test = perc_test,\n               only_presence = TRUE, \n               seed = seed)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_sp\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_sp\n```\n:::\n\n\n### Create folds for cross-validation\n\nAs we will use cross-validation during the model training, we create the folds\nin advance. In this case we use random folds, but other methods exist.\nSince we are limited by the number of presence records, we will create only \n4 folds. The algorithm will iteratively use 3 folds to train and 1 to validate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create folds \nran_folds <- randomFolds(train_sp, \n                         k = k,\n                         only_presence = TRUE, \n                         seed = seed)\n```\n:::\n\n\n### Train a default Maxent model with CV\n\nWe will first train a so called *full model*, i.e., a model with all predictors,\nand from there we'll remove those that are highly correlated and not so important.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train a full model\nfull_model_sp <- train(method = method,\n                       data = train_sp, \n                       folds = ran_folds)\n\nfull_model_sp\n```\n:::\n\n\nLet's see the predictions of the full model\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_full_model <- predict(full_model_sp,\n                           data = env,\n                           type = \"cloglog\")\n\nmapview(raster::raster(pred_full_model))\n```\n:::\n\n\n### Variable selection: remove highly correlated variables \n\nWe proceed then to remove correlated predictors as they provide highly redundant\ninformation and might affect the performance of models, i.e., as with all \nmodels, we want it to be simple and of the highest possible performance. We will\nuse the area under the ROC curve (AUC) as the performance metric, and eliminate \ncorrelated variables only if AUC decreases if we keep them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare background locations to test correlation\nbg_sp <- prepareSWD(species = sp, \n                    a = background,\n                    env = env)\n\n# Remove variables with correlation higher than 0.7 \n# while accounting for the AUC\nvs_sp <- varSel(full_model_sp,\n                metric = \"auc\", \n                bg4cor = bg_sp, \n                cor_th = cor_th,\n                permut = perm,\n                interactive = FALSE)\n```\n:::\n\n\nLet's explore the output object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvs_sp@data\n```\n:::\n\n\n### Remove less important variables\n\nAfter discarding correlated variables, we will also remove variables that have a\npercent contribution or importance lower than 10%, again accounting for AUC.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remove less important variables only if auc does not decrease\nreduc_var_sp <- reduceVar(vs_sp,\n                          th = imp_th, \n                          metric = \"auc\", \n                          test = TRUE, \n                          permut = perm, \n                          use_jk = TRUE,\n                          interactive = FALSE)\n```\n:::\n\n\nLet's explore the result\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduc_var_sp\n```\n:::\n\n\nWe need now to recreate the SWD object and train/test datasets, but with the \nselected variables only, in order to run the final model and make predictions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get only relevant variables from the reduced model\nretained_varnames <- names(reduc_var_sp@models[[1]]@data@data)\n\n# Subset stack\nenv <- terra::subset(env, retained_varnames)\n\n# SWD with the selected vars\nsubset_train_sp <- prepareSWD(species = sp, \n                              p = presence_coords,\n                              a = background,\n                              env = env)\n\nc(train_sp, test_sp) %<-% \n  trainValTest(subset_train_sp, \n               test = perc_test, \n               only_presence = TRUE, \n               seed = seed)\n```\n:::\n\n\n### Run the best model and make predictions\n\nNow we train the final model with the full training set, we no longer need\nthe folds at this point. Note that we also use the feature classes (fc) and\nregularization (reg) from the best model obtained before. In this case, they \nare default values only, but if we also do hyper-parameter optimization, they\nmight differ.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_model_sp <- train(method = method, \n                        data = train_sp,\n                        fc = reduc_var_sp@models[[1]]@model@fc,\n                        reg = reduc_var_sp@models[[1]]@model@reg)\n```\n:::\n\n\nLet's make predictions now and explore the result\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_sp_maxent <- predict(final_model_sp,\n                         data = env, \n                         type = \"cloglog\")\n\nmapview(raster::raster(map_sp_maxent))\n```\n:::\n\n\n### Write result back to GRASS \n\nWe can now write the raster with the final model's predictions into the GRASS\ndatabase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_RAST(map_sp_maxent, \n           \"Aedes_albopictus_maxent\", \n           flags = c(\"o\",\"overwrite\"))\n```\n:::\n\n\nCheck the map is there\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexecGRASS(\"g.list\", \n          parameters = list(type=\"raster\",\n                            pattern=\"Aedes*\"))\n```\n:::\n\n\n### Model evaluation\n\nWe want to know how good our model is, so in this step we use the test dataset\nthat we separated in the beginning. An AUC of 0.5 would mean the model performs\nlike flipping a coin. AUC is what we call a threshold independent evaluation\nmetric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# AUC\nauc_maxent <- auc(final_model_sp, test = test_sp)\nauc_maxent\n```\n:::\n\n\nUsually, however, the result of SDM is converted into presence/absence maps. To\ndetermine which threshold to use we perform threshold dependent evaluations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Threshold dependent evaluation\nth_maxent <- thresholds(final_model_sp, \n                        type = \"cloglog\", \n                        test = test_sp)\n\nknitr::kable(th_maxent, format = 'html', digits = 2)\n```\n:::\n\nLet's choose one threshold and create a binary map\n\n\n::: {.cell}\n\n```{.r .cell-code}\np = map_sp_maxent >= 0.5\na = map_sp_maxent < 0.5\nmap_sp_maxent[p] <- 1\nmap_sp_maxent[a] <- 0\n\nmapview(raster::raster(map_sp_maxent))\n```\n:::\n\n\n\n### Variable importance\n\nVariable importance is an indicator of variable contribution to prediction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvi_model_sp <- maxentVarImp(final_model_sp)\nvi_model_sp\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotVarImp(vi_model_sp)\n```\n:::\n\n\n\n### Response curves\n\nResponse curves give us an idea of the relationship between predictor variables \nand probability of occurrence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_rp <- function(i){\n  plotResponse(reduc_var_sp, i)\n}\n\nplotlist <- lapply(retained_varnames, my_rp)\n\nlabels <- LETTERS[1:length(retained_varnames)]\n\nggpubr::ggarrange(plotlist = plotlist, labels = labels)\n```\n:::\n\n\nWe close the mapset and done\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# close the mapset\nunlink_.gislock()\n```\n:::\n\n\n\n### Disclaimer\n\nThis is only a simple example for doing SDM and only the beginning... \nThere are:\n\n- other models to test\n- hyper-parameter tuning\n- ensemble modeling\n- uncertainty assessment: where we can predict with confidence\n- many other relevant packages: \n  - [*dismo*](https://cran.r-project.org/web/packages/dismo/index.html), [*sdm*](https://cran.r-project.org/web/packages/sdm/index.html),  [*kuenm*](https://github.com/marlonecobos/kuenm), [*caret*](https://cran.r-project.org/web/packages/caret/index.html), [*CAST*](https://cran.r-project.org/web/packages/CAST/index.html), etc.\n\n## References\n\n:::{#refs}\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}